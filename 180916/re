re模块包含对正则表达式的支持。查找满足特定任务需要的那部分内容。
1.什么是正则表达式？
*通配符
可以匹配多于1个的字符串，使用一些特殊字符创建这类模式。如点号（.）只能匹配一个字母，不是两个或零个。
可以匹配"任何字符"（除换行符外的任何单个字符），点号称为通配符。如：.ython可以匹配'python'、'jypthon'不能是'cpython'、'ython'
*对特殊字符进行转义
'python\\.org' 这样就知会匹配'python.org'
*字符集
如'[pj]ython'能够匹配'python'和'jython'
'[a-z]'能够（按字母顺序）匹配a到z的任意一个字符。
'[a-zA-Z0-9]'能够匹配任意大小写字母和数字（注意字符集只能匹配一个这样的字符）。
'[^abc]'为了反转字符集可以在开头使用^字符，比如'[^abc]'可以匹配任何出了a、b和c之外的字符。
注：特殊字符用做文本字符而不是正则表达式运算符，需要用反斜线进行转义。如^脱字符出现在字符集的开头、] -
*选择符和子模式
字符串的每个字符都各不相同的情况下，使用选择项的特殊字符(|)。如：'p(ython|erl)'。
*可选项和重复子模式
在子模式后面加上问号就变成了可选项。它可能出现在匹配字符串中，但并非必需的。
如：r'(http://)?(www\.)?python\.org'
只能匹配下列字符串：
'http://www.python.org'
'http://python.org'
'www.python.org'
'python.org'
上述例子值得注意的点：
（1）对点号进行了转义，防止它被作为通配符使用；
（2）使用原始字符串减少所需反斜线的数量；
（3）每个可选子模式都用圆括号括起；
（4）可选子模式出现与否均可，而且互相独立；
问号表示子模式可以出现一次或者根本不出现。下面这些运算符允许子模式重复多次：
(pattern)*:允许模式重复0次或多次；
(pattern）+:允许模式重复1次或多次；
(pattern){m,n}:允许模式重复m~n次。
例1：r'w*\.python\.org'匹配'www.python.org'、 '.python.org'、'ww.python.org'、'wwwwwww.python.org'
例2：r'w+\.python\.org'匹配'w.python.org'不能匹配'.python.org'
例3：r'w{3,4}\.python\.org'匹配'www.python.org'和'wwww.python.org'
*字符串的开始和结尾
上述所出现的模式匹配都是针对整个字符串的，但是也能寻找匹配模式的子字符串。
例1:字符串"www.python.org"中的子字符串'www'会能够匹配模式'w+',在寻找这样的子字符串时，
    确定子字符串位于整个字符串的开始还是结尾是很有用的.
例2：只想在字符串的开头而不是其他位置匹配'ht+p',那么就可以使用脱字符（^）标记开始:
    ^ht+p会匹配'http://python.org'(以及'httttp://python.org'),但是不匹配'www.http.org'
    类似地，字符串结尾用美元符号（$）标识。
2.re模块的内容
re模块中一些重要的函数
compile(pattern[flags])根据包含正则表达式的字符串创建模式对象
search(pattern,string[flags])在字符串中寻找模式
match(pattern,string[flags])在字符串的开始处匹配模式
split(pattern,string[maxsplit=0])根据模式的匹配项来分割字符串
findall(pattern,string)列出字符串中模式的所有匹配项
sub(pat,repl,string[count=0])将字符串中所有pat的匹配项用repl替换
escape(string)将字符串中所有特殊正则表达式字符转义
说明：
函数re.compile将正则表达式转换为模式对象，可以实现更有效率的匹配。

函数re.search会在给定字符串中寻找第一个匹配给定正则表达式的子字符串。
一旦找到子字符串，函数就会返回MatchObject（值为True）,否则返回None（值为False）。

函数re.match会在给定字符串的开头匹配正则表达式。如：match('p','python')返回真，
而re.match('p','www.python.org')则返回假（None）。

函数re.split会根据模式的匹配项来分割字符串。类似字符串方法split，不过是用完整的正则表达式代替了固定的分隔符字符串。
比如字符串方法split允许用字符串','的匹配项来分割字符串，而re.split允许用任意长度的逗号和空格序列来分割字符串。

函数re.findall以列表形式返回给定模式的所有匹配项。比如，在字符串中查找所有的单词。

函数re.sub的作用在于：使用给定的替换内容将匹配模式的子字符串（最左端并且非重叠的子字符串）替换掉。

函数re.escape可以对字符串中所有可能被解释为正则运算符的字符进行转义的应用函数。
3.匹配对象和组
re模块中能够对字符串进行模式匹配的函数而言，当能找到匹配项的时候，它们都会返回MatchObject对象。这些对象包括匹配模式的子字符串的信息。
还包含哪个模块匹配了子字符串哪部分的信息-这些"部分"叫做组（group）。简而言之，组就是放置在圆括号内的子模式。组的序号取决于它左侧的
括号数。组0就是整个模式：
如：'There (was a (wee)(cooper)) who (lived in Fyfe)'
包含下面这些组：
0 There was a wee cooper who lived in Fyfe
1 was a wee cooper
2 wee
3 cooper
4 lived in Fyfe

re.match与re.search的区别
re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。
4. 替换中的组号和函数
在第一个re.sub使用示例中，我只是将一个子串替换为另一个。这也可使用字符串方法 replace(参见3.4节)轻松地完成。当然，正则表达式很有用，
因为它们让你能够以更灵活的方 式进行搜索，还让你能够执行更复杂的替换。
为利用re.sub的强大功能，最简单的方式是在替代字符串中使用组号。在替换字符串中，任 何类似于'\\n'的转义序列都将被替换为与模式中编组n匹配的字符串。
例如，假设要将 '*something*'替换为'<em>something</em>'，其中前者是在纯文本文档(如电子邮件)中表示突 出的普通方式，而后者是相应的HTML代码
(用于网页中)。
5. 找出发件人
6. 模板系统示例
模板(template)是一种文件，可在其中插入具体的值来得到最终的文本。例如，可能有一 个只需插入收件人姓名的邮件模板。Python提供了一种高级模板机制:
字符串格式设置。使用正 则表达式可让这个系统更加高级。假设要把所有的'[something]'(字段)都替换为将something 作为Python表达式计算得到的结果。
(1)可使用正则表达式来匹配字段并提取其内容。
(2)可使用eval来计算表达式字符串，并提供包含作用域的字典。可在try/except语句中执行这种操作。如果出现SyntaxError异常，就说明你处理的可能是语句
(如赋值语句)而不 是表达式，应使用exec来执行它。
(3)可使用exec来执行语句字符串(和其他语句)，并将模板的作用域存储到字典中。
(4)可使用re.sub将被处理的字符串替换为计算得到的结果。

10.3.9 其他有趣的标准模块
argparse:在UNIX中，运行命令行程序时常常需要指定各种选项(开关)，Python解释器 就是这样的典范。这些选项都包含在sys.argv中，但要正确地处理
         它们绝非容易。模块 argparse使得提供功能齐备的命令行界面易如反掌。
cmd:这个模块让你能够编写类似于Python交互式解释器的命令行解释器。你可定义命令，让用户能够在提示符下执行它们。
csv:CSV指的是逗号分隔的值(comma-seperated values)，很多应用程序(如很多电子表格程序和数据库程序)都使用这种简单格式来存储表格数据。这种
    格式主要用于在不同的程序之间交换数据。模块csv让你能够轻松地读写CSV文件，它还以非常透明的方式处理CSV格式的一些棘手部分。
datetime:如果模块time不能满足你的时间跟踪需求，模块datetime很可能能够满足。datetime支持特殊的日期和时间对象，并让你能够以各种方式创建和
         合并这些对象。相比于模块time，模块datetime的接口在很多方面都更加直观。
difflib:这个库让你能够确定两个序列的相似程度，还让你能够从很多序列中找出与指定序列最为相似的序列。例如，可使用difflib来创建简单的搜索程序。
enum:枚举类型是一种只有少数几个可能取值的类型。很多语言都内置了这样的类型，如果你在使用Python时需要这样的类型，模块enum可提供极大的帮助。
functools:这个模块提供的功能是让你能够在调用函数时只提供部分参数(部分求值，partial evaluation)，以后再填充其他的参数。在Python 3.0
          中，这个模块包含filter和reduce。
hashlib:使用这个模块可计算字符串的小型“签名”(数)。计算两个不同字符串的签名时，几乎可以肯定得到的两个签名是不同的。你可使用它来计算大型文本
        文件的签名，这个模块在加密和安全领域有很多用途。
itertools:包含大量用于创建和合并迭代器(或其他可迭代对象)的工具，其中包括可以串接可迭代对象、创建返回无限连续整数的迭代器(类似于range，但没
          有上限)、反复 遍历可迭代对象以及具有其他作用的函数。
logging:使用print语句来确定程序中发生的情况很有用。要避免跟踪时出现大量调试输出，可将这些信息写入日志文件中。这个模块提供了一系列标准工具，
        可用于管理一个或多个中央日志，它还支持多种优先级不同的日志消息。
timeit、profile和trace:模块timeit(和配套的命令行脚本)是一个测量代码段执行时间的工具。这个模块暗藏玄机，度量性能时你可能应该使用它而不是
模块time。模块profile(和配套模块pstats)可用于对代码段的效率进行更全面的分析。模块trace可帮助你进行覆盖率分析(即代码的哪些部分执行了，哪
些部分没有执行)，这在编写测试代码时很有用。

小结：
模块:模块基本上是一个子程序，主要作用是定义函数、类和变量等。模块包含测试代码时，应将这些代码放在一条检查name == '__main__'的if语句中。
    如果模块位于环境变量PYTHONPATH包含的目录中，就可直接导入它;要导入存储在文件foo.py中的模块，可使用语句import foo。
包:包不过是包含其他模块的模块。包是使用包含文件__init__.py的目录实现的。
探索模块:在交互式解释器中导入模块后，就可以众多不同的方式对其进行探索，其中 包括使用dir、查看变量__all__以及使用函数help。文档和源代码也是
        获取信息和洞见的极佳来源。
标准库:Python自带多个模块，统称为标准库。本章介绍了其中的几个。
 sys:这个模块让你能够访问多个与Python解释器关系紧密的变量和函数。
 os:这个模块让你能够访问多个与操作系统关系紧密的变量和函数。
 fileinput:这个模块让你能够轻松地迭代多个文件或流的内容行。
 sets、heapq和deque:这三个模块提供了三种很有用的数据结构。内置类型set也实现了集合。
 time:这个模块让你能够获取当前时间、操作时间和日期以及设置它们的格式。
 random:这个模块包含用于生成随机数，从序列中随机地选择元素，以及打乱列表中元素的函数。
 shelve:这个模块用于创建永久性映射，其内容存储在使用给定文件名的数据库中。
 re:支持正则表达式的模块。
dir(obj) help([obj]) imp.reload(module)
返回一个按字母顺序排列的属性名列表
提供交互式帮助或有关特定对象的帮助信息
返回已导入的模块的重载版本